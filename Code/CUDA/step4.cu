#include <cuda_runtime.h>
#include <iostream>
#include <algorithm>

__global__ void update_y(float* y_next, const float* w, const float* GL, const float* z, const float* pD, int m, int n) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < m) {
        float result = w[idx] + pD[idx];
        for (int j = 0; j < n; j++) {
            result += GL[idx * n + j] * z[j];
        }
        y_next[idx] = fmaxf(result, 0.0f); // Projection onto non-negative orthant
    }
}
// Main function probably doesn't work. I need to test it. This was auto generated by the copilot. 
// Doesn't use cudamemcpy. 
int main() {
    int m = 1000;
    int n = 100;
    float* y_next;
    float* w;
    float* GL;
    float* z;
    float* pD;
    cudaMallocManaged(&y_next, m * sizeof(float));
    cudaMallocManaged(&w, m * sizeof(float));
    cudaMallocManaged(&GL, m * n * sizeof(float));
    cudaMallocManaged(&z, n * sizeof(float));
    cudaMallocManaged(&pD, m * sizeof(float));

    // Initialize y_next, w, GL, z, pD
    for (int i = 0; i < m; i++) {
        y_next[i] = 0.0f;
        w[i] = 0.0f;
        pD[i] = 0.0f;
    }
    for (int i = 0; i < m * n; i++) {
        GL[i] = 0.0f;
    }
    for (int i = 0; i < n; i++) {
        z[i] = 0.0f;
    }

    // Launch kernel
    int blockSize = 256;
    int numBlocks = (m + blockSize - 1) / blockSize;
    update_y<<<numBlocks, blockSize>>>(y_next, w, GL, z, pD, m, n);
    cudaDeviceSynchronize();

    // Free memory
    cudaFree(y_next);
    cudaFree(w);
    cudaFree(GL);
    cudaFree(z);
    cudaFree(pD);

    return 0;
}